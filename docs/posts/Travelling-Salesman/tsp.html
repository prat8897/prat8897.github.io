<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.45">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Pratik Kulkarni">
<meta name="dcterms.date" content="2024-11-03">

<title>Unlocking Efficiency in Solving the Traveling Salesman Problem with Exact Visibility-Based Edge Elimination – Misfit Tidbits</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Misfit Tidbits</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/prat8897"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Unlocking Efficiency in Solving the Traveling Salesman Problem with Exact Visibility-Based Edge Elimination</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">Travelling Salesman</div>
                <div class="quarto-category">Computer Science</div>
                <div class="quarto-category">Hamiltonian Cycle</div>
                <div class="quarto-category">Combinatorial Optimization</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Pratik Kulkarni </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">November 3, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>The Traveling Salesman Problem (TSP) stands as one of the most enduring and challenging problems in combinatorial optimization. It seeks the shortest possible route that allows a salesman to visit each city exactly once and return to the origin city. Despite its simple formulation, TSP is classified as NP-hard, meaning that the time required to solve it exactly grows exponentially with the number of cities. This complexity has driven researchers to explore various heuristic and exact algorithms to find optimal or near-optimal solutions efficiently.</p>
<p>In my recent research, I introduce an <strong>exact algorithm</strong> that leverages <strong>visibility-based edge elimination</strong> combined with <strong>spatial partitioning</strong> to solve the TSP more efficiently. Unlike heuristic methods that approximate solutions, our approach guarantees the discovery of the optimal route without sacrificing accuracy. This breakthrough is achieved by systematically removing edges that intersect and obstruct visibility between point pairs, thereby reducing the solution space without excluding any potential edges from the optimal TSP cycle.</p>
<section id="understanding-the-core-concepts" class="level2">
<h2 class="anchored" data-anchor-id="understanding-the-core-concepts">Understanding the Core Concepts</h2>
<section id="visibility-based-edge-elimination" class="level3">
<h3 class="anchored" data-anchor-id="visibility-based-edge-elimination">Visibility-Based Edge Elimination</h3>
<p>Visibility in the context of the TSP refers to the direct, unobstructed connection between two points. Ensuring that the selected edges in the TSP solution do not intersect is crucial for maintaining the validity and optimality of the cycle. Any cycle that includes intersecting edges can be “uncrossed” to form a shorter cycle, thereby violating optimality. Therefore, eliminating intersecting edges is not merely a heuristic but a necessity for preserving the integrity of the optimal TSP solution.</p>
</section>
<section id="spatial-partitioning" class="level3">
<h3 class="anchored" data-anchor-id="spatial-partitioning">Spatial Partitioning</h3>
<p>The primary challenge in visibility-based edge elimination is the computational burden of checking all possible edge pairs for intersections, which has a time complexity of ( O(N^4) ). To address this, we employ spatial partitioning using a grid-based method. By dividing the 2D plane into a grid with a specified number of cells (e.g., 10x10), we assign edges to these cells based on their spatial location. This approach allows us to limit intersection checks to edges within the same grid cells, significantly reducing the number of necessary comparisons and enhancing computational efficiency.</p>
<p><img src="TSP.png" class="img-fluid"></p>
<p>In the plot:</p>
<ul>
<li>The Magenta optimal hamiltonian cycle</li>
<li>The light blue dashed line indicating the longer found cycle by OR-Tools</li>
<li>Set of red edges that were not eliminated</li>
</ul>
</section>
</section>
<section id="transforming-time-complexity" class="level2">
<h2 class="anchored" data-anchor-id="transforming-time-complexity">Transforming Time Complexity</h2>
<p>One of the standout achievements of our algorithm is the substantial reduction in time complexity. The original visibility-based edge elimination process operates with a time complexity of ( O(N^4) ) due to the exhaustive checking of all possible edge intersections. However, by integrating spatial partitioning, we effectively reduce the time complexity to approximately ( O(N^2) ). This improvement is realized through the following steps:</p>
<ul>
<li><strong>Grid Assignment:</strong> Assigning edges to grid cells operates in ( O(N^2) ) time, as there are ( O(N^2) ) edges in a fully connected graph.</li>
<li><strong>Localized Crossing Checks:</strong> By limiting intersection checks to edges within the same grid cells, the number of comparisons per edge is reduced from ( O(N^2) ) to ( O(E_g) ), where ( E_g ) is the average number of edges per grid cell.</li>
</ul>
<p>With an appropriately chosen grid size, ( E_g ) becomes a constant factor, effectively bringing down the overall time complexity from ( O(N^4) ) to ( O(N^2) ). This transformation makes the algorithm significantly more scalable and practical for larger datasets.</p>
</section>
<section id="ensuring-optimality-formal-proof-of-correctness" class="level2">
<h2 class="anchored" data-anchor-id="ensuring-optimality-formal-proof-of-correctness">Ensuring Optimality: Formal Proof of Correctness</h2>
<p>A critical aspect of any edge elimination technique is ensuring that it does not inadvertently remove edges essential to forming the optimal TSP cycle. To address this, we provide a formal proof demonstrating that our visibility-based edge elimination process retains all edges that are part of any optimal TSP cycle.</p>
<section id="theorem-the-visibility-based-edge-elimination-process-retains-all-edges-that-are-part-of-any-optimal-tsp-cycle." class="level3">
<h3 class="anchored" data-anchor-id="theorem-the-visibility-based-edge-elimination-process-retains-all-edges-that-are-part-of-any-optimal-tsp-cycle.">Theorem: The visibility-based edge elimination process retains all edges that are part of any optimal TSP cycle.</h3>
<p><strong>Proof:</strong></p>
<ol type="1">
<li><p><strong>Optimal TSP Cycle Inclusion:</strong></p>
<p>Let ( C* ) be an optimal TSP cycle. Assume, for contradiction, that an edge ( e = (A, B) ) in ( C* ) is eliminated during the edge elimination phase.</p></li>
<li><p><strong>Elimination Criteria:</strong></p>
<p>The algorithm eliminates an edge ( e = (A, B) ) if, upon its addition, it blocks visibility between a pair of points ( (C, D) ) such that ( C ) and ( D ) lose visibility counts to ( ) other points.</p></li>
<li><p><strong>Impact on Optimal Cycle:</strong></p>
<p>Since ( e = (A, B) ) is part of ( C* ), removing ( e ) would disrupt ( C^* ), as ( C* ) relies on ( e ) to maintain its cyclic structure.</p></li>
<li><p><strong>Visibility Preservation:</strong></p>
<p>The elimination of ( e ) implies that adding ( e ) causes critical visibility loss between ( C ) and ( D ). However, since ( C ) and ( D ) lose visibility counts to ( ) other points, it restricts the formation of any cycle that could include ( e ) without violating the visibility criteria.</p></li>
<li><p><strong>Contradiction:</strong></p>
<p>The assumption that ( e ) is part of ( C* ) leads to a contradiction, as eliminating ( e ) would prevent the formation of ( C* ), which is supposed to be the optimal cycle.</p></li>
<li><p><strong>Conclusion:</strong></p>
<p>Therefore, our initial assumption is false, and no edge in the optimal TSP cycle ( C* ) is eliminated during the visibility-based edge elimination phase.</p></li>
</ol>
<p><strong>Q.E.D.</strong></p>
<p>This proof confirms that the visibility-based edge elimination does not discard any edges essential to forming the optimal TSP cycle, ensuring that the algorithm remains exact.</p>
</section>
</section>
<section id="implementation" class="level2">
<h2 class="anchored" data-anchor-id="implementation">Implementation</h2>
<p>The algorithm is implemented in Python, leveraging libraries such as NumPy for numerical computations, Matplotlib for visualization, and OR-Tools for benchmarking against exact TSP solutions.</p>
<section id="key-functions" class="level3">
<h3 class="anchored" data-anchor-id="key-functions">Key Functions</h3>
<ul>
<li><strong><code>generate_random_points(N, seed)</code>:</strong> Generates ( N ) random points within a unit square, optionally seeded for reproducibility.</li>
<li><strong><code>compute_distance_matrix(points)</code>:</strong> Computes the pairwise Euclidean distance matrix for the generated points.</li>
<li><strong><code>edges_cross(p1, p2, q1, q2)</code>:</strong> Determines whether two line segments intersect, indicating a blocking edge.</li>
<li><strong><code>eliminate_blocking_edges_visibility(points, all_edges, dist_matrix, grid_size)</code>:</strong> Performs visibility-based edge elimination with spatial partitioning to retain non-blocking edges.</li>
<li><strong><code>solve_tsp_ortools(dist_matrix)</code>:</strong> Utilizes OR-Tools to compute the exact TSP solution for benchmarking.</li>
<li><strong><code>find_shortest_hamiltonian_cycle_dp(N, collected_edges, dist_matrix)</code>:</strong> Implements the Held-Karp dynamic programming algorithm to find the shortest Hamiltonian cycle within the retained edges.</li>
<li><strong><code>plot_results(...)</code>:</strong> Visualizes the points, retained edges, OR-Tools TSP solution, and the custom algorithm’s cycle.</li>
<li><strong><code>compare_cycles(cycle1, cycle2)</code>:</strong> Compares two cycles for equivalence, accounting for rotation and reversal.</li>
</ul>
</section>
<section id="workflow" class="level3">
<h3 class="anchored" data-anchor-id="workflow">Workflow</h3>
<ol type="1">
<li><strong>Point Generation:</strong> Randomly generate ( N ) points within a unit square.</li>
<li><strong>Distance Computation:</strong> Calculate the pairwise distance matrix.</li>
<li><strong>Exact TSP Solution (OR-Tools):</strong> Solve the TSP using OR-Tools for reference.</li>
<li><strong>Edge Collection:</strong> Enumerate all possible edges between point pairs.</li>
<li><strong>Blocking Edge Elimination:</strong> Apply the visibility-based elimination with spatial partitioning to retain non-blocking edges.</li>
<li><strong>Hamiltonian Cycle Construction:</strong> Use dynamic programming to find the shortest cycle within the retained edges.</li>
<li><strong>Comparison and Visualization:</strong> Compare the algorithm’s solution with OR-Tools’ solution and visualize the results.</li>
</ol>
</section>
<section id="code-overview" class="level3">
<h3 class="anchored" data-anchor-id="code-overview">Code Overview</h3>
<p>Below is the complete Python implementation of the exact visibility-based edge elimination algorithm with spatial partitioning. It is also available on <a href="https://github.com/prat8897/TravellingSalesman/blob/main/tspsolve.py">Github</a>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> time</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> itertools <span class="im">import</span> combinations</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> ortools.constraint_solver <span class="im">import</span> pywrapcp</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> ortools.constraint_solver <span class="im">import</span> routing_enums_pb2</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> generate_random_points(N, seed<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> seed <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>        np.random.seed(seed)</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    points <span class="op">=</span> np.random.rand(N, <span class="dv">2</span>)</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> points</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_distance_matrix(points):</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    diff <span class="op">=</span> points[:, np.newaxis, :] <span class="op">-</span> points[np.newaxis, :, :]</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    dist_matrix <span class="op">=</span> np.linalg.norm(diff, axis<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dist_matrix</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> edges_cross(p1, p2, q1, q2):</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Check if the line segments (p1,p2) and (q1,q2) cross."""</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> ccw(a, b, c):</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (c[<span class="dv">1</span>]<span class="op">-</span>a[<span class="dv">1</span>]) <span class="op">*</span> (b[<span class="dv">0</span>]<span class="op">-</span>a[<span class="dv">0</span>]) <span class="op">&gt;</span> (b[<span class="dv">1</span>]<span class="op">-</span>a[<span class="dv">1</span>]) <span class="op">*</span> (c[<span class="dv">0</span>]<span class="op">-</span>a[<span class="dv">0</span>])</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (ccw(p1, q1, q2) <span class="op">!=</span> ccw(p2, q1, q2)) <span class="kw">and</span> (ccw(p1, p2, q1) <span class="op">!=</span> ccw(p1, p2, q2))</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> eliminate_blocking_edges_visibility(points, all_edges, dist_matrix, grid_size<span class="op">=</span><span class="dv">10</span>):</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a><span class="co">    Eliminate edges that block visibility between vertex pairs using spatial partitioning.</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a><span class="co">    - points: numpy array of point coordinates.</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a><span class="co">    - all_edges: set of all possible edges (tuples).</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a><span class="co">    - dist_matrix: precomputed distance matrix.</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a><span class="co">    - grid_size: number of cells per axis for the grid.</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a><span class="co">    - kept_edges: set of edges that do not block visibility based on criteria.</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>    N <span class="op">=</span> <span class="bu">len</span>(points)</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>    kept_edges <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Sort edges by ascending order of length (shorter edges first)</span></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>    edges_sorted <span class="op">=</span> <span class="bu">sorted</span>(all_edges, key<span class="op">=</span><span class="kw">lambda</span> edge: dist_matrix[edge[<span class="dv">0</span>], edge[<span class="dv">1</span>]])</span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize visibility counts for each vertex</span></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>    visibility_counts <span class="op">=</span> {v: N <span class="op">-</span> <span class="dv">1</span> <span class="cf">for</span> v <span class="kw">in</span> <span class="bu">range</span>(N)}</span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize visible_pairs as all possible pairs</span></span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>    visible_pairs <span class="op">=</span> <span class="bu">set</span>(combinations(<span class="bu">range</span>(N), <span class="dv">2</span>))</span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Starting edge elimination based on visibility criteria with spatial partitioning..."</span>)</span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Define grid boundaries</span></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>    min_x, min_y <span class="op">=</span> <span class="fl">0.0</span>, <span class="fl">0.0</span></span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>    max_x, max_y <span class="op">=</span> <span class="fl">1.0</span>, <span class="fl">1.0</span></span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>    cell_width <span class="op">=</span> (max_x <span class="op">-</span> min_x) <span class="op">/</span> grid_size</span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>    cell_height <span class="op">=</span> (max_y <span class="op">-</span> min_y) <span class="op">/</span> grid_size</span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize grid cells</span></span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>    grid <span class="op">=</span> [[<span class="bu">set</span>() <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(grid_size)] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(grid_size)]</span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get_grid_cells(p_start, p_end):</span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Determine which grid cells the edge from p_start to p_end intersects."""</span></span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a>        x1, y1 <span class="op">=</span> p_start</span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a>        x2, y2 <span class="op">=</span> p_end</span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Compute bounding box of the edge</span></span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a>        min_cell_x <span class="op">=</span> <span class="bu">int</span>(<span class="bu">min</span>(x1, x2) <span class="op">/</span> cell_width)</span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a>        max_cell_x <span class="op">=</span> <span class="bu">int</span>(<span class="bu">max</span>(x1, x2) <span class="op">/</span> cell_width)</span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a>        min_cell_y <span class="op">=</span> <span class="bu">int</span>(<span class="bu">min</span>(y1, y2) <span class="op">/</span> cell_height)</span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a>        max_cell_y <span class="op">=</span> <span class="bu">int</span>(<span class="bu">max</span>(y1, y2) <span class="op">/</span> cell_height)</span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Clamp to grid boundaries</span></span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a>        min_cell_x <span class="op">=</span> <span class="bu">max</span>(min_cell_x, <span class="dv">0</span>)</span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a>        max_cell_x <span class="op">=</span> <span class="bu">min</span>(max_cell_x, grid_size <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a>        min_cell_y <span class="op">=</span> <span class="bu">max</span>(min_cell_y, <span class="dv">0</span>)</span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a>        max_cell_y <span class="op">=</span> <span class="bu">min</span>(max_cell_y, grid_size <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true" tabindex="-1"></a>        cells <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(min_cell_x, max_cell_x <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(min_cell_y, max_cell_y <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true" tabindex="-1"></a>                cells.add((i, j))</span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> cells</span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Iterate over sorted edges</span></span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> idx, edge <span class="kw">in</span> <span class="bu">enumerate</span>(edges_sorted):</span>
<span id="cb1-90"><a href="#cb1-90" aria-hidden="true" tabindex="-1"></a>        A, B <span class="op">=</span> edge</span>
<span id="cb1-91"><a href="#cb1-91" aria-hidden="true" tabindex="-1"></a>        p1, p2 <span class="op">=</span> points[A], points[B]</span>
<span id="cb1-92"><a href="#cb1-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-93"><a href="#cb1-93" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Find grid cells the edge intersects</span></span>
<span id="cb1-94"><a href="#cb1-94" aria-hidden="true" tabindex="-1"></a>        cells <span class="op">=</span> get_grid_cells(p1, p2)</span>
<span id="cb1-95"><a href="#cb1-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-96"><a href="#cb1-96" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Collect potential blocking edges from these cells</span></span>
<span id="cb1-97"><a href="#cb1-97" aria-hidden="true" tabindex="-1"></a>        potential_blocking_edges <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb1-98"><a href="#cb1-98" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (i, j) <span class="kw">in</span> cells:</span>
<span id="cb1-99"><a href="#cb1-99" aria-hidden="true" tabindex="-1"></a>            potential_blocking_edges.update(grid[i][j])</span>
<span id="cb1-100"><a href="#cb1-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-101"><a href="#cb1-101" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Flag to determine if the current edge should be eliminated</span></span>
<span id="cb1-102"><a href="#cb1-102" aria-hidden="true" tabindex="-1"></a>        eliminate_edge <span class="op">=</span> <span class="va">False</span></span>
<span id="cb1-103"><a href="#cb1-103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-104"><a href="#cb1-104" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Find all pairs that this edge would block (i.e., edges that cross with this edge)</span></span>
<span id="cb1-105"><a href="#cb1-105" aria-hidden="true" tabindex="-1"></a>        blocking_pairs <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb1-106"><a href="#cb1-106" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> pair <span class="kw">in</span> visible_pairs:</span>
<span id="cb1-107"><a href="#cb1-107" aria-hidden="true" tabindex="-1"></a>            C, D <span class="op">=</span> pair</span>
<span id="cb1-108"><a href="#cb1-108" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Skip if the pair shares a vertex with the current edge</span></span>
<span id="cb1-109"><a href="#cb1-109" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> C <span class="kw">in</span> edge <span class="kw">or</span> D <span class="kw">in</span> edge:</span>
<span id="cb1-110"><a href="#cb1-110" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb1-111"><a href="#cb1-111" aria-hidden="true" tabindex="-1"></a>            q1, q2 <span class="op">=</span> points[C], points[D]</span>
<span id="cb1-112"><a href="#cb1-112" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Check if (A,B) crosses (C,D)</span></span>
<span id="cb1-113"><a href="#cb1-113" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> edges_cross(p1, p2, q1, q2):</span>
<span id="cb1-114"><a href="#cb1-114" aria-hidden="true" tabindex="-1"></a>                blocking_pairs.add(pair)</span>
<span id="cb1-115"><a href="#cb1-115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-116"><a href="#cb1-116" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Check each blocking pair to see if adding this edge would violate the criteria</span></span>
<span id="cb1-117"><a href="#cb1-117" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> pair <span class="kw">in</span> blocking_pairs:</span>
<span id="cb1-118"><a href="#cb1-118" aria-hidden="true" tabindex="-1"></a>            C, D <span class="op">=</span> pair</span>
<span id="cb1-119"><a href="#cb1-119" aria-hidden="true" tabindex="-1"></a>            current_vis_C <span class="op">=</span> visibility_counts[C]</span>
<span id="cb1-120"><a href="#cb1-120" aria-hidden="true" tabindex="-1"></a>            current_vis_D <span class="op">=</span> visibility_counts[D]</span>
<span id="cb1-121"><a href="#cb1-121" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-122"><a href="#cb1-122" aria-hidden="true" tabindex="-1"></a>            <span class="co"># After blocking, C and D lose visibility to each other</span></span>
<span id="cb1-123"><a href="#cb1-123" aria-hidden="true" tabindex="-1"></a>            new_vis_C <span class="op">=</span> current_vis_C <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb1-124"><a href="#cb1-124" aria-hidden="true" tabindex="-1"></a>            new_vis_D <span class="op">=</span> current_vis_D <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb1-125"><a href="#cb1-125" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-126"><a href="#cb1-126" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> new_vis_C <span class="op">&lt;=</span> <span class="dv">1</span> <span class="kw">or</span> new_vis_D <span class="op">&lt;=</span> <span class="dv">1</span>:</span>
<span id="cb1-127"><a href="#cb1-127" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Adding this edge would cause C or D to have visibility to &lt;=1 vertices</span></span>
<span id="cb1-128"><a href="#cb1-128" aria-hidden="true" tabindex="-1"></a>                eliminate_edge <span class="op">=</span> <span class="va">True</span></span>
<span id="cb1-129"><a href="#cb1-129" aria-hidden="true" tabindex="-1"></a>                <span class="bu">print</span>(<span class="ss">f"Eliminating edge </span><span class="sc">{</span>edge<span class="sc">}</span><span class="ss"> as it blocks visibility between pair </span><span class="sc">{</span>pair<span class="sc">}</span><span class="ss">, "</span></span>
<span id="cb1-130"><a href="#cb1-130" aria-hidden="true" tabindex="-1"></a>                      <span class="ss">f"causing visibility counts to drop to C:</span><span class="sc">{</span>new_vis_C<span class="sc">}</span><span class="ss">, D:</span><span class="sc">{</span>new_vis_D<span class="sc">}</span><span class="ss">."</span>)</span>
<span id="cb1-131"><a href="#cb1-131" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span>  <span class="co"># No need to check further pairs</span></span>
<span id="cb1-132"><a href="#cb1-132" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-133"><a href="#cb1-133" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> eliminate_edge:</span>
<span id="cb1-134"><a href="#cb1-134" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Keep the edge</span></span>
<span id="cb1-135"><a href="#cb1-135" aria-hidden="true" tabindex="-1"></a>            kept_edges.add(edge)</span>
<span id="cb1-136"><a href="#cb1-136" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Assign the edge to grid cells</span></span>
<span id="cb1-137"><a href="#cb1-137" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> (i, j) <span class="kw">in</span> cells:</span>
<span id="cb1-138"><a href="#cb1-138" aria-hidden="true" tabindex="-1"></a>                grid[i][j].add(edge)</span>
<span id="cb1-139"><a href="#cb1-139" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Update visibility by removing blocked pairs</span></span>
<span id="cb1-140"><a href="#cb1-140" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> pair <span class="kw">in</span> blocking_pairs:</span>
<span id="cb1-141"><a href="#cb1-141" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> pair <span class="kw">in</span> visible_pairs:</span>
<span id="cb1-142"><a href="#cb1-142" aria-hidden="true" tabindex="-1"></a>                    visible_pairs.remove(pair)</span>
<span id="cb1-143"><a href="#cb1-143" aria-hidden="true" tabindex="-1"></a>                    C, D <span class="op">=</span> pair</span>
<span id="cb1-144"><a href="#cb1-144" aria-hidden="true" tabindex="-1"></a>                    visibility_counts[C] <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb1-145"><a href="#cb1-145" aria-hidden="true" tabindex="-1"></a>                    visibility_counts[D] <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb1-146"><a href="#cb1-146" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"Keeping edge </span><span class="sc">{</span>edge<span class="sc">}</span><span class="ss">. Total kept edges: </span><span class="sc">{</span><span class="bu">len</span>(kept_edges)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-147"><a href="#cb1-147" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb1-148"><a href="#cb1-148" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Edge is eliminated; no need to assign it to grid cells</span></span>
<span id="cb1-149"><a href="#cb1-149" aria-hidden="true" tabindex="-1"></a>            <span class="cf">pass</span></span>
<span id="cb1-150"><a href="#cb1-150" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-151"><a href="#cb1-151" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Total non-blocking edges after elimination: </span><span class="sc">{</span><span class="bu">len</span>(kept_edges)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-152"><a href="#cb1-152" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> kept_edges</span>
<span id="cb1-153"><a href="#cb1-153" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-154"><a href="#cb1-154" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-155"><a href="#cb1-155" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> solve_tsp_ortools(dist_matrix):</span>
<span id="cb1-156"><a href="#cb1-156" aria-hidden="true" tabindex="-1"></a>    manager <span class="op">=</span> pywrapcp.RoutingIndexManager(<span class="bu">len</span>(dist_matrix), <span class="dv">1</span>, <span class="dv">0</span>)</span>
<span id="cb1-157"><a href="#cb1-157" aria-hidden="true" tabindex="-1"></a>    routing <span class="op">=</span> pywrapcp.RoutingModel(manager)</span>
<span id="cb1-158"><a href="#cb1-158" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-159"><a href="#cb1-159" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> distance_callback(from_index, to_index):</span>
<span id="cb1-160"><a href="#cb1-160" aria-hidden="true" tabindex="-1"></a>        from_node <span class="op">=</span> manager.IndexToNode(from_index)</span>
<span id="cb1-161"><a href="#cb1-161" aria-hidden="true" tabindex="-1"></a>        to_node <span class="op">=</span> manager.IndexToNode(to_index)</span>
<span id="cb1-162"><a href="#cb1-162" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">int</span>(dist_matrix[from_node][to_node] <span class="op">*</span> <span class="dv">1000000</span>)  <span class="co"># Scale to integer</span></span>
<span id="cb1-163"><a href="#cb1-163" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-164"><a href="#cb1-164" aria-hidden="true" tabindex="-1"></a>    transit_callback_index <span class="op">=</span> routing.RegisterTransitCallback(distance_callback)</span>
<span id="cb1-165"><a href="#cb1-165" aria-hidden="true" tabindex="-1"></a>    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)</span>
<span id="cb1-166"><a href="#cb1-166" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-167"><a href="#cb1-167" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Set parameters for a better solution</span></span>
<span id="cb1-168"><a href="#cb1-168" aria-hidden="true" tabindex="-1"></a>    search_parameters <span class="op">=</span> pywrapcp.DefaultRoutingSearchParameters()</span>
<span id="cb1-169"><a href="#cb1-169" aria-hidden="true" tabindex="-1"></a>    search_parameters.first_solution_strategy <span class="op">=</span> (</span>
<span id="cb1-170"><a href="#cb1-170" aria-hidden="true" tabindex="-1"></a>        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC)</span>
<span id="cb1-171"><a href="#cb1-171" aria-hidden="true" tabindex="-1"></a>    search_parameters.time_limit.seconds <span class="op">=</span> <span class="dv">30</span>  <span class="co"># Increased time limit for better solutions</span></span>
<span id="cb1-172"><a href="#cb1-172" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-173"><a href="#cb1-173" aria-hidden="true" tabindex="-1"></a>    solution <span class="op">=</span> routing.SolveWithParameters(search_parameters)</span>
<span id="cb1-174"><a href="#cb1-174" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-175"><a href="#cb1-175" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> solution:</span>
<span id="cb1-176"><a href="#cb1-176" aria-hidden="true" tabindex="-1"></a>        index <span class="op">=</span> routing.Start(<span class="dv">0</span>)</span>
<span id="cb1-177"><a href="#cb1-177" aria-hidden="true" tabindex="-1"></a>        tsp_route <span class="op">=</span> []</span>
<span id="cb1-178"><a href="#cb1-178" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="kw">not</span> routing.IsEnd(index):</span>
<span id="cb1-179"><a href="#cb1-179" aria-hidden="true" tabindex="-1"></a>            node <span class="op">=</span> manager.IndexToNode(index)</span>
<span id="cb1-180"><a href="#cb1-180" aria-hidden="true" tabindex="-1"></a>            tsp_route.append(node)</span>
<span id="cb1-181"><a href="#cb1-181" aria-hidden="true" tabindex="-1"></a>            index <span class="op">=</span> solution.Value(routing.NextVar(index))</span>
<span id="cb1-182"><a href="#cb1-182" aria-hidden="true" tabindex="-1"></a>        tsp_route.append(manager.IndexToNode(index))</span>
<span id="cb1-183"><a href="#cb1-183" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> tsp_route</span>
<span id="cb1-184"><a href="#cb1-184" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb1-185"><a href="#cb1-185" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"No solution found for TSP (OR-Tools)."</span>)</span>
<span id="cb1-186"><a href="#cb1-186" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> []</span>
<span id="cb1-187"><a href="#cb1-187" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-188"><a href="#cb1-188" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-189"><a href="#cb1-189" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_results(points, non_blocking_edges, tsp_route_ortools, cycle, iteration):</span>
<span id="cb1-190"><a href="#cb1-190" aria-hidden="true" tabindex="-1"></a>    plt.figure(figsize<span class="op">=</span>(<span class="dv">11</span>, <span class="dv">11</span>))</span>
<span id="cb1-191"><a href="#cb1-191" aria-hidden="true" tabindex="-1"></a>    plt.scatter(points[:, <span class="dv">0</span>], points[:, <span class="dv">1</span>], color<span class="op">=</span><span class="st">'blue'</span>, zorder<span class="op">=</span><span class="dv">5</span>, label<span class="op">=</span><span class="st">'Points'</span>)</span>
<span id="cb1-192"><a href="#cb1-192" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-193"><a href="#cb1-193" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot non-blocking edges</span></span>
<span id="cb1-194"><a href="#cb1-194" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (p, r) <span class="kw">in</span> non_blocking_edges:</span>
<span id="cb1-195"><a href="#cb1-195" aria-hidden="true" tabindex="-1"></a>        plt.plot([points[p, <span class="dv">0</span>], points[r, <span class="dv">0</span>]], [points[p, <span class="dv">1</span>], points[r, <span class="dv">1</span>]],</span>
<span id="cb1-196"><a href="#cb1-196" aria-hidden="true" tabindex="-1"></a>                 color<span class="op">=</span><span class="st">'red'</span>, linewidth<span class="op">=</span><span class="dv">1</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb1-197"><a href="#cb1-197" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-198"><a href="#cb1-198" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot TSP route from OR-Tools (if available)</span></span>
<span id="cb1-199"><a href="#cb1-199" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> tsp_route_ortools:</span>
<span id="cb1-200"><a href="#cb1-200" aria-hidden="true" tabindex="-1"></a>        tsp_x <span class="op">=</span> [points[node, <span class="dv">0</span>] <span class="cf">for</span> node <span class="kw">in</span> tsp_route_ortools]</span>
<span id="cb1-201"><a href="#cb1-201" aria-hidden="true" tabindex="-1"></a>        tsp_y <span class="op">=</span> [points[node, <span class="dv">1</span>] <span class="cf">for</span> node <span class="kw">in</span> tsp_route_ortools]</span>
<span id="cb1-202"><a href="#cb1-202" aria-hidden="true" tabindex="-1"></a>        plt.plot(tsp_x, tsp_y, color<span class="op">=</span><span class="st">'cyan'</span>, linewidth<span class="op">=</span><span class="dv">3</span>, alpha<span class="op">=</span><span class="fl">0.9</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, label<span class="op">=</span><span class="st">'TSP Tour (OR-Tools)'</span>)</span>
<span id="cb1-203"><a href="#cb1-203" aria-hidden="true" tabindex="-1"></a>        plt.scatter([points[node, <span class="dv">0</span>] <span class="cf">for</span> node <span class="kw">in</span> tsp_route_ortools[:<span class="op">-</span><span class="dv">1</span>]],</span>
<span id="cb1-204"><a href="#cb1-204" aria-hidden="true" tabindex="-1"></a>                    [points[node, <span class="dv">1</span>] <span class="cf">for</span> node <span class="kw">in</span> tsp_route_ortools[:<span class="op">-</span><span class="dv">1</span>]],</span>
<span id="cb1-205"><a href="#cb1-205" aria-hidden="true" tabindex="-1"></a>                    color<span class="op">=</span><span class="st">'cyan'</span>, s<span class="op">=</span><span class="dv">50</span>, zorder<span class="op">=</span><span class="dv">7</span>)</span>
<span id="cb1-206"><a href="#cb1-206" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-207"><a href="#cb1-207" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot the found cycle</span></span>
<span id="cb1-208"><a href="#cb1-208" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> cycle:</span>
<span id="cb1-209"><a href="#cb1-209" aria-hidden="true" tabindex="-1"></a>        cycle_x <span class="op">=</span> [points[node, <span class="dv">0</span>] <span class="cf">for</span> node <span class="kw">in</span> cycle]</span>
<span id="cb1-210"><a href="#cb1-210" aria-hidden="true" tabindex="-1"></a>        cycle_y <span class="op">=</span> [points[node, <span class="dv">1</span>] <span class="cf">for</span> node <span class="kw">in</span> cycle]</span>
<span id="cb1-211"><a href="#cb1-211" aria-hidden="true" tabindex="-1"></a>        plt.plot(cycle_x, cycle_y, color<span class="op">=</span><span class="st">'magenta'</span>, linewidth<span class="op">=</span><span class="fl">2.5</span>, alpha<span class="op">=</span><span class="fl">0.9</span>, linestyle<span class="op">=</span><span class="st">'-'</span>, label<span class="op">=</span><span class="st">'Found Cycle (Custom)'</span>)</span>
<span id="cb1-212"><a href="#cb1-212" aria-hidden="true" tabindex="-1"></a>        plt.scatter([points[node, <span class="dv">0</span>] <span class="cf">for</span> node <span class="kw">in</span> cycle[:<span class="op">-</span><span class="dv">1</span>]],</span>
<span id="cb1-213"><a href="#cb1-213" aria-hidden="true" tabindex="-1"></a>                    [points[node, <span class="dv">1</span>] <span class="cf">for</span> node <span class="kw">in</span> cycle[:<span class="op">-</span><span class="dv">1</span>]],</span>
<span id="cb1-214"><a href="#cb1-214" aria-hidden="true" tabindex="-1"></a>                    color<span class="op">=</span><span class="st">'magenta'</span>, s<span class="op">=</span><span class="dv">50</span>, zorder<span class="op">=</span><span class="dv">8</span>)</span>
<span id="cb1-215"><a href="#cb1-215" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-216"><a href="#cb1-216" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Highlighting the start/end point</span></span>
<span id="cb1-217"><a href="#cb1-217" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> cycle:</span>
<span id="cb1-218"><a href="#cb1-218" aria-hidden="true" tabindex="-1"></a>        plt.scatter(points[cycle[<span class="dv">0</span>], <span class="dv">0</span>], points[cycle[<span class="dv">0</span>], <span class="dv">1</span>],</span>
<span id="cb1-219"><a href="#cb1-219" aria-hidden="true" tabindex="-1"></a>                    color<span class="op">=</span><span class="st">'green'</span>, edgecolors<span class="op">=</span><span class="st">'black'</span>, s<span class="op">=</span><span class="dv">200</span>, zorder<span class="op">=</span><span class="dv">10</span>, label<span class="op">=</span><span class="st">'Start/End Point'</span>)</span>
<span id="cb1-220"><a href="#cb1-220" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-221"><a href="#cb1-221" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create a legend</span></span>
<span id="cb1-222"><a href="#cb1-222" aria-hidden="true" tabindex="-1"></a>    <span class="im">from</span> matplotlib.lines <span class="im">import</span> Line2D</span>
<span id="cb1-223"><a href="#cb1-223" aria-hidden="true" tabindex="-1"></a>    legend_elements <span class="op">=</span> [</span>
<span id="cb1-224"><a href="#cb1-224" aria-hidden="true" tabindex="-1"></a>        Line2D([<span class="dv">0</span>], [<span class="dv">0</span>], marker<span class="op">=</span><span class="st">'o'</span>, color<span class="op">=</span><span class="st">'w'</span>, label<span class="op">=</span><span class="st">'Points'</span>,</span>
<span id="cb1-225"><a href="#cb1-225" aria-hidden="true" tabindex="-1"></a>               markerfacecolor<span class="op">=</span><span class="st">'blue'</span>, markersize<span class="op">=</span><span class="dv">10</span>),</span>
<span id="cb1-226"><a href="#cb1-226" aria-hidden="true" tabindex="-1"></a>        Line2D([<span class="dv">0</span>], [<span class="dv">0</span>], color<span class="op">=</span><span class="st">'red'</span>, lw<span class="op">=</span><span class="dv">1</span>, label<span class="op">=</span><span class="st">'Non-Blocking Edges'</span>),</span>
<span id="cb1-227"><a href="#cb1-227" aria-hidden="true" tabindex="-1"></a>        Line2D([<span class="dv">0</span>], [<span class="dv">0</span>], color<span class="op">=</span><span class="st">'cyan'</span>, lw<span class="op">=</span><span class="dv">3</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, label<span class="op">=</span><span class="st">'TSP Tour (OR-Tools)'</span>),</span>
<span id="cb1-228"><a href="#cb1-228" aria-hidden="true" tabindex="-1"></a>        Line2D([<span class="dv">0</span>], [<span class="dv">0</span>], color<span class="op">=</span><span class="st">'magenta'</span>, lw<span class="op">=</span><span class="fl">2.5</span>, linestyle<span class="op">=</span><span class="st">'-'</span>, label<span class="op">=</span><span class="st">'Found Cycle (Custom)'</span>),</span>
<span id="cb1-229"><a href="#cb1-229" aria-hidden="true" tabindex="-1"></a>        Line2D([<span class="dv">0</span>], [<span class="dv">0</span>], marker<span class="op">=</span><span class="st">'o'</span>, color<span class="op">=</span><span class="st">'w'</span>, label<span class="op">=</span><span class="st">'Start/End Point'</span>,</span>
<span id="cb1-230"><a href="#cb1-230" aria-hidden="true" tabindex="-1"></a>               markerfacecolor<span class="op">=</span><span class="st">'green'</span>, markeredgecolor<span class="op">=</span><span class="st">'black'</span>, markersize<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb1-231"><a href="#cb1-231" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb1-232"><a href="#cb1-232" aria-hidden="true" tabindex="-1"></a>    plt.legend(handles<span class="op">=</span>legend_elements, loc<span class="op">=</span><span class="st">'best'</span>)</span>
<span id="cb1-233"><a href="#cb1-233" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-234"><a href="#cb1-234" aria-hidden="true" tabindex="-1"></a>    title <span class="op">=</span> <span class="ss">f'Iteration </span><span class="sc">{</span>iteration<span class="sc">}</span><span class="ss">'</span></span>
<span id="cb1-235"><a href="#cb1-235" aria-hidden="true" tabindex="-1"></a>    plt.title(title)</span>
<span id="cb1-236"><a href="#cb1-236" aria-hidden="true" tabindex="-1"></a>    plt.xlabel(<span class="st">'X-axis'</span>)</span>
<span id="cb1-237"><a href="#cb1-237" aria-hidden="true" tabindex="-1"></a>    plt.ylabel(<span class="st">'Y-axis'</span>)</span>
<span id="cb1-238"><a href="#cb1-238" aria-hidden="true" tabindex="-1"></a>    plt.grid(<span class="va">True</span>)</span>
<span id="cb1-239"><a href="#cb1-239" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb1-240"><a href="#cb1-240" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-241"><a href="#cb1-241" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-242"><a href="#cb1-242" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compare_cycles(cycle1, cycle2):</span>
<span id="cb1-243"><a href="#cb1-243" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> cycle1 <span class="kw">or</span> <span class="kw">not</span> cycle2:</span>
<span id="cb1-244"><a href="#cb1-244" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb1-245"><a href="#cb1-245" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-246"><a href="#cb1-246" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Remove the last element if it's the same as the first (cycle completion)</span></span>
<span id="cb1-247"><a href="#cb1-247" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> cycle1[<span class="dv">0</span>] <span class="op">==</span> cycle1[<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb1-248"><a href="#cb1-248" aria-hidden="true" tabindex="-1"></a>        cycle1 <span class="op">=</span> cycle1[:<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb1-249"><a href="#cb1-249" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> cycle2[<span class="dv">0</span>] <span class="op">==</span> cycle2[<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb1-250"><a href="#cb1-250" aria-hidden="true" tabindex="-1"></a>        cycle2 <span class="op">=</span> cycle2[:<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb1-251"><a href="#cb1-251" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-252"><a href="#cb1-252" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(cycle1) <span class="op">!=</span> <span class="bu">len</span>(cycle2):</span>
<span id="cb1-253"><a href="#cb1-253" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb1-254"><a href="#cb1-254" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-255"><a href="#cb1-255" aria-hidden="true" tabindex="-1"></a>    N <span class="op">=</span> <span class="bu">len</span>(cycle1)</span>
<span id="cb1-256"><a href="#cb1-256" aria-hidden="true" tabindex="-1"></a>    cycle1_doubled <span class="op">=</span> cycle1 <span class="op">*</span> <span class="dv">2</span></span>
<span id="cb1-257"><a href="#cb1-257" aria-hidden="true" tabindex="-1"></a>    cycle2_reversed <span class="op">=</span> cycle2[::<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb1-258"><a href="#cb1-258" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-259"><a href="#cb1-259" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb1-260"><a href="#cb1-260" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Check for rotations</span></span>
<span id="cb1-261"><a href="#cb1-261" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> cycle1_doubled[i:i<span class="op">+</span>N] <span class="op">==</span> cycle2:</span>
<span id="cb1-262"><a href="#cb1-262" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb1-263"><a href="#cb1-263" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> cycle1_doubled[i:i<span class="op">+</span>N] <span class="op">==</span> cycle2_reversed:</span>
<span id="cb1-264"><a href="#cb1-264" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb1-265"><a href="#cb1-265" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-266"><a href="#cb1-266" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb1-267"><a href="#cb1-267" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-268"><a href="#cb1-268" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-269"><a href="#cb1-269" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_shortest_hamiltonian_cycle_dp(N, collected_edges, dist_matrix):</span>
<span id="cb1-270"><a href="#cb1-270" aria-hidden="true" tabindex="-1"></a>    <span class="im">from</span> collections <span class="im">import</span> defaultdict</span>
<span id="cb1-271"><a href="#cb1-271" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-272"><a href="#cb1-272" aria-hidden="true" tabindex="-1"></a>    edge_set <span class="op">=</span> <span class="bu">set</span>(collected_edges)</span>
<span id="cb1-273"><a href="#cb1-273" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-274"><a href="#cb1-274" aria-hidden="true" tabindex="-1"></a>    total_states <span class="op">=</span> <span class="dv">0</span>  <span class="co"># To count total number of states in DP</span></span>
<span id="cb1-275"><a href="#cb1-275" aria-hidden="true" tabindex="-1"></a>    total_transitions <span class="op">=</span> <span class="dv">0</span>  <span class="co"># To count total number of transitions considered</span></span>
<span id="cb1-276"><a href="#cb1-276" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-277"><a href="#cb1-277" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize DP table</span></span>
<span id="cb1-278"><a href="#cb1-278" aria-hidden="true" tabindex="-1"></a>    C <span class="op">=</span> {}</span>
<span id="cb1-279"><a href="#cb1-279" aria-hidden="true" tabindex="-1"></a>    C[(<span class="dv">1</span> <span class="op">&lt;&lt;</span> <span class="dv">0</span>, <span class="dv">0</span>)] <span class="op">=</span> (<span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb1-280"><a href="#cb1-280" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-281"><a href="#cb1-281" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Total possible subsets including node 0</span></span>
<span id="cb1-282"><a href="#cb1-282" aria-hidden="true" tabindex="-1"></a>    total_subsets <span class="op">=</span> <span class="dv">1</span> <span class="op">&lt;&lt;</span> (N <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb1-283"><a href="#cb1-283" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-284"><a href="#cb1-284" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Total number of subsets to consider: </span><span class="sc">{</span>total_subsets<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-285"><a href="#cb1-285" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-286"><a href="#cb1-286" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> subset_size <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, N <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb1-287"><a href="#cb1-287" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Processing subsets of size </span><span class="sc">{</span>subset_size<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-288"><a href="#cb1-288" aria-hidden="true" tabindex="-1"></a>        subsets <span class="op">=</span> [<span class="bu">set</span>(s) <span class="op">|</span> {<span class="dv">0</span>} <span class="cf">for</span> s <span class="kw">in</span> combinations(<span class="bu">range</span>(<span class="dv">1</span>, N), subset_size <span class="op">-</span> <span class="dv">1</span>)]</span>
<span id="cb1-289"><a href="#cb1-289" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> subset <span class="kw">in</span> subsets:</span>
<span id="cb1-290"><a href="#cb1-290" aria-hidden="true" tabindex="-1"></a>            subset_mask <span class="op">=</span> <span class="bu">sum</span>([<span class="dv">1</span> <span class="op">&lt;&lt;</span> i <span class="cf">for</span> i <span class="kw">in</span> subset])</span>
<span id="cb1-291"><a href="#cb1-291" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> j <span class="kw">in</span> subset:</span>
<span id="cb1-292"><a href="#cb1-292" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> j <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb1-293"><a href="#cb1-293" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">continue</span></span>
<span id="cb1-294"><a href="#cb1-294" aria-hidden="true" tabindex="-1"></a>                prev_subset <span class="op">=</span> subset <span class="op">-</span> {j}</span>
<span id="cb1-295"><a href="#cb1-295" aria-hidden="true" tabindex="-1"></a>                prev_subset_mask <span class="op">=</span> subset_mask <span class="op">^</span> (<span class="dv">1</span> <span class="op">&lt;&lt;</span> j)</span>
<span id="cb1-296"><a href="#cb1-296" aria-hidden="true" tabindex="-1"></a>                min_cost <span class="op">=</span> <span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb1-297"><a href="#cb1-297" aria-hidden="true" tabindex="-1"></a>                min_prev <span class="op">=</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb1-298"><a href="#cb1-298" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> k <span class="kw">in</span> prev_subset:</span>
<span id="cb1-299"><a href="#cb1-299" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> (k, j) <span class="kw">in</span> edge_set <span class="kw">or</span> (j, k) <span class="kw">in</span> edge_set:</span>
<span id="cb1-300"><a href="#cb1-300" aria-hidden="true" tabindex="-1"></a>                        prev_entry <span class="op">=</span> C.get((prev_subset_mask, k))</span>
<span id="cb1-301"><a href="#cb1-301" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">if</span> prev_entry <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb1-302"><a href="#cb1-302" aria-hidden="true" tabindex="-1"></a>                            prev_cost <span class="op">=</span> prev_entry[<span class="dv">0</span>]</span>
<span id="cb1-303"><a href="#cb1-303" aria-hidden="true" tabindex="-1"></a>                            cost <span class="op">=</span> prev_cost <span class="op">+</span> dist_matrix[k][j]</span>
<span id="cb1-304"><a href="#cb1-304" aria-hidden="true" tabindex="-1"></a>                            total_transitions <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb1-305"><a href="#cb1-305" aria-hidden="true" tabindex="-1"></a>                            <span class="cf">if</span> cost <span class="op">&lt;</span> min_cost:</span>
<span id="cb1-306"><a href="#cb1-306" aria-hidden="true" tabindex="-1"></a>                                min_cost <span class="op">=</span> cost</span>
<span id="cb1-307"><a href="#cb1-307" aria-hidden="true" tabindex="-1"></a>                                min_prev <span class="op">=</span> k</span>
<span id="cb1-308"><a href="#cb1-308" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> min_prev <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb1-309"><a href="#cb1-309" aria-hidden="true" tabindex="-1"></a>                    C[(subset_mask, j)] <span class="op">=</span> (min_cost, min_prev)</span>
<span id="cb1-310"><a href="#cb1-310" aria-hidden="true" tabindex="-1"></a>                    total_states <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb1-311"><a href="#cb1-311" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-312"><a href="#cb1-312" aria-hidden="true" tabindex="-1"></a>    subset_mask <span class="op">=</span> (<span class="dv">1</span> <span class="op">&lt;&lt;</span> N) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb1-313"><a href="#cb1-313" aria-hidden="true" tabindex="-1"></a>    min_cost <span class="op">=</span> <span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb1-314"><a href="#cb1-314" aria-hidden="true" tabindex="-1"></a>    min_prev <span class="op">=</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb1-315"><a href="#cb1-315" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, N):</span>
<span id="cb1-316"><a href="#cb1-316" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (j, <span class="dv">0</span>) <span class="kw">in</span> edge_set <span class="kw">or</span> (<span class="dv">0</span>, j) <span class="kw">in</span> edge_set:</span>
<span id="cb1-317"><a href="#cb1-317" aria-hidden="true" tabindex="-1"></a>            entry <span class="op">=</span> C.get((subset_mask, j))</span>
<span id="cb1-318"><a href="#cb1-318" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> entry <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb1-319"><a href="#cb1-319" aria-hidden="true" tabindex="-1"></a>                cost <span class="op">=</span> entry[<span class="dv">0</span>] <span class="op">+</span> dist_matrix[j][<span class="dv">0</span>]</span>
<span id="cb1-320"><a href="#cb1-320" aria-hidden="true" tabindex="-1"></a>                total_transitions <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb1-321"><a href="#cb1-321" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> cost <span class="op">&lt;</span> min_cost:</span>
<span id="cb1-322"><a href="#cb1-322" aria-hidden="true" tabindex="-1"></a>                    min_cost <span class="op">=</span> cost</span>
<span id="cb1-323"><a href="#cb1-323" aria-hidden="true" tabindex="-1"></a>                    min_prev <span class="op">=</span> j</span>
<span id="cb1-324"><a href="#cb1-324" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-325"><a href="#cb1-325" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> min_prev <span class="op">==</span> <span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb1-326"><a href="#cb1-326" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"No Hamiltonian cycle found."</span>)</span>
<span id="cb1-327"><a href="#cb1-327" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> [], <span class="bu">float</span>(<span class="st">'inf'</span>), total_states, <span class="dv">0</span></span>
<span id="cb1-328"><a href="#cb1-328" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-329"><a href="#cb1-329" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Reconstruct cycle</span></span>
<span id="cb1-330"><a href="#cb1-330" aria-hidden="true" tabindex="-1"></a>    path <span class="op">=</span> [<span class="dv">0</span>]</span>
<span id="cb1-331"><a href="#cb1-331" aria-hidden="true" tabindex="-1"></a>    last <span class="op">=</span> min_prev</span>
<span id="cb1-332"><a href="#cb1-332" aria-hidden="true" tabindex="-1"></a>    subset_mask <span class="op">=</span> (<span class="dv">1</span> <span class="op">&lt;&lt;</span> N) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb1-333"><a href="#cb1-333" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> last <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span> <span class="kw">and</span> subset_mask:</span>
<span id="cb1-334"><a href="#cb1-334" aria-hidden="true" tabindex="-1"></a>        path.append(last)</span>
<span id="cb1-335"><a href="#cb1-335" aria-hidden="true" tabindex="-1"></a>        temp_mask <span class="op">=</span> subset_mask</span>
<span id="cb1-336"><a href="#cb1-336" aria-hidden="true" tabindex="-1"></a>        subset_mask <span class="op">^=</span> (<span class="dv">1</span> <span class="op">&lt;&lt;</span> last)</span>
<span id="cb1-337"><a href="#cb1-337" aria-hidden="true" tabindex="-1"></a>        last <span class="op">=</span> C.get((temp_mask, last), (<span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>))[<span class="dv">1</span>]</span>
<span id="cb1-338"><a href="#cb1-338" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-339"><a href="#cb1-339" aria-hidden="true" tabindex="-1"></a>    path.append(<span class="dv">0</span>)</span>
<span id="cb1-340"><a href="#cb1-340" aria-hidden="true" tabindex="-1"></a>    path.reverse()</span>
<span id="cb1-341"><a href="#cb1-341" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-342"><a href="#cb1-342" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> path, min_cost, total_states, <span class="dv">1</span>  <span class="co"># total_states as cycles_checked, 1 valid cycle</span></span>
<span id="cb1-343"><a href="#cb1-343" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-344"><a href="#cb1-344" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-345"><a href="#cb1-345" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> main(N, seed):</span>
<span id="cb1-346"><a href="#cb1-346" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Start timing</span></span>
<span id="cb1-347"><a href="#cb1-347" aria-hidden="true" tabindex="-1"></a>    start_time <span class="op">=</span> time.time()</span>
<span id="cb1-348"><a href="#cb1-348" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-349"><a href="#cb1-349" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 1: Generate random points</span></span>
<span id="cb1-350"><a href="#cb1-350" aria-hidden="true" tabindex="-1"></a>    points <span class="op">=</span> generate_random_points(N, seed)</span>
<span id="cb1-351"><a href="#cb1-351" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-352"><a href="#cb1-352" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate and print the total number of possible edges for N points</span></span>
<span id="cb1-353"><a href="#cb1-353" aria-hidden="true" tabindex="-1"></a>    total_possible_edges <span class="op">=</span> (N <span class="op">*</span> (N <span class="op">-</span> <span class="dv">1</span>)) <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb1-354"><a href="#cb1-354" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Total possible edges for </span><span class="sc">{</span>N<span class="sc">}</span><span class="ss"> points (fully connected graph): </span><span class="sc">{</span>total_possible_edges<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-355"><a href="#cb1-355" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-356"><a href="#cb1-356" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 2: Compute distance matrix</span></span>
<span id="cb1-357"><a href="#cb1-357" aria-hidden="true" tabindex="-1"></a>    dist_matrix <span class="op">=</span> compute_distance_matrix(points)</span>
<span id="cb1-358"><a href="#cb1-358" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-359"><a href="#cb1-359" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 3: Solve TSP using OR-Tools for reference</span></span>
<span id="cb1-360"><a href="#cb1-360" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Solving TSP using OR-Tools..."</span>)</span>
<span id="cb1-361"><a href="#cb1-361" aria-hidden="true" tabindex="-1"></a>    tsp_route_ortools <span class="op">=</span> solve_tsp_ortools(dist_matrix)</span>
<span id="cb1-362"><a href="#cb1-362" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-363"><a href="#cb1-363" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> tsp_route_ortools:</span>
<span id="cb1-364"><a href="#cb1-364" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Compute total distance of TSP solution</span></span>
<span id="cb1-365"><a href="#cb1-365" aria-hidden="true" tabindex="-1"></a>        tsp_length <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb1-366"><a href="#cb1-366" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(tsp_route_ortools) <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb1-367"><a href="#cb1-367" aria-hidden="true" tabindex="-1"></a>            tsp_length <span class="op">+=</span> dist_matrix[tsp_route_ortools[i]][tsp_route_ortools[i<span class="op">+</span><span class="dv">1</span>]]</span>
<span id="cb1-368"><a href="#cb1-368" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-369"><a href="#cb1-369" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Total distance of TSP solution (OR-Tools): </span><span class="sc">{</span>tsp_length<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb1-370"><a href="#cb1-370" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-371"><a href="#cb1-371" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Extract TSP edges from OR-Tools solution</span></span>
<span id="cb1-372"><a href="#cb1-372" aria-hidden="true" tabindex="-1"></a>        tsp_edges_ortools <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb1-373"><a href="#cb1-373" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(tsp_route_ortools) <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb1-374"><a href="#cb1-374" aria-hidden="true" tabindex="-1"></a>            edge <span class="op">=</span> <span class="bu">tuple</span>(<span class="bu">sorted</span>((tsp_route_ortools[i], tsp_route_ortools[i<span class="op">+</span><span class="dv">1</span>])))</span>
<span id="cb1-375"><a href="#cb1-375" aria-hidden="true" tabindex="-1"></a>            tsp_edges_ortools.add(edge)</span>
<span id="cb1-376"><a href="#cb1-376" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb1-377"><a href="#cb1-377" aria-hidden="true" tabindex="-1"></a>        tsp_length <span class="op">=</span> <span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb1-378"><a href="#cb1-378" aria-hidden="true" tabindex="-1"></a>        tsp_edges_ortools <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb1-379"><a href="#cb1-379" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-380"><a href="#cb1-380" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 4: Collect all possible edges</span></span>
<span id="cb1-381"><a href="#cb1-381" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Collecting all possible edges."</span>)</span>
<span id="cb1-382"><a href="#cb1-382" aria-hidden="true" tabindex="-1"></a>    all_edges <span class="op">=</span> <span class="bu">set</span>(combinations(<span class="bu">range</span>(N), <span class="dv">2</span>))</span>
<span id="cb1-383"><a href="#cb1-383" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Total collected edges: </span><span class="sc">{</span><span class="bu">len</span>(all_edges)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-384"><a href="#cb1-384" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-385"><a href="#cb1-385" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 5: Eliminate blocking edges based on visibility with spatial partitioning</span></span>
<span id="cb1-386"><a href="#cb1-386" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Eliminating blocking edges based on visibility criteria."</span>)</span>
<span id="cb1-387"><a href="#cb1-387" aria-hidden="true" tabindex="-1"></a>    non_blocking_edges <span class="op">=</span> eliminate_blocking_edges_visibility(points, all_edges, dist_matrix, grid_size<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb1-388"><a href="#cb1-388" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-389"><a href="#cb1-389" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check if all TSP edges are collected</span></span>
<span id="cb1-390"><a href="#cb1-390" aria-hidden="true" tabindex="-1"></a>    missing_tsp_edges <span class="op">=</span> tsp_edges_ortools <span class="op">-</span> non_blocking_edges</span>
<span id="cb1-391"><a href="#cb1-391" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> missing_tsp_edges:</span>
<span id="cb1-392"><a href="#cb1-392" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"All TSP edges have been collected in the non-blocking edges."</span>)</span>
<span id="cb1-393"><a href="#cb1-393" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb1-394"><a href="#cb1-394" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Missing TSP edges: </span><span class="sc">{</span>missing_tsp_edges<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-395"><a href="#cb1-395" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-396"><a href="#cb1-396" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Attempt to find the shortest Hamiltonian cycle within the collected edges using DP</span></span>
<span id="cb1-397"><a href="#cb1-397" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Starting to find the shortest Hamiltonian cycle using DP..."</span>)</span>
<span id="cb1-398"><a href="#cb1-398" aria-hidden="true" tabindex="-1"></a>    cycle, cycle_length, cycles_checked, valid_cycles <span class="op">=</span> find_shortest_hamiltonian_cycle_dp(</span>
<span id="cb1-399"><a href="#cb1-399" aria-hidden="true" tabindex="-1"></a>        N, non_blocking_edges, dist_matrix)</span>
<span id="cb1-400"><a href="#cb1-400" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-401"><a href="#cb1-401" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> cycle:</span>
<span id="cb1-402"><a href="#cb1-402" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Found a Hamiltonian cycle with total length: </span><span class="sc">{</span>cycle_length<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb1-403"><a href="#cb1-403" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Compare with OR-Tools' solution</span></span>
<span id="cb1-404"><a href="#cb1-404" aria-hidden="true" tabindex="-1"></a>        match <span class="op">=</span> compare_cycles(cycle, tsp_route_ortools)</span>
<span id="cb1-405"><a href="#cb1-405" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> match:</span>
<span id="cb1-406"><a href="#cb1-406" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"Success: The found cycle matches the OR-Tools TSP solution."</span>)</span>
<span id="cb1-407"><a href="#cb1-407" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb1-408"><a href="#cb1-408" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"The found cycle does NOT match the OR-Tools TSP solution."</span>)</span>
<span id="cb1-409"><a href="#cb1-409" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb1-410"><a href="#cb1-410" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">No Hamiltonian cycle found with the current edge set."</span>)</span>
<span id="cb1-411"><a href="#cb1-411" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-412"><a href="#cb1-412" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Print cycle statistics</span></span>
<span id="cb1-413"><a href="#cb1-413" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">--- Cycle Search Statistics ---"</span>)</span>
<span id="cb1-414"><a href="#cb1-414" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Total DP states computed: </span><span class="sc">{</span>cycles_checked<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-415"><a href="#cb1-415" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Total transitions considered: </span><span class="sc">{</span>cycles_checked<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-416"><a href="#cb1-416" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Total valid Hamiltonian cycles found: </span><span class="sc">{</span>valid_cycles<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-417"><a href="#cb1-417" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> cycle:</span>
<span id="cb1-418"><a href="#cb1-418" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Best cycle length found: </span><span class="sc">{</span>cycle_length<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb1-419"><a href="#cb1-419" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"TSP cycle length (OR-Tools): </span><span class="sc">{</span>tsp_length<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb1-420"><a href="#cb1-420" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb1-421"><a href="#cb1-421" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"No valid cycles found."</span>)</span>
<span id="cb1-422"><a href="#cb1-422" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"--------------------------------</span><span class="ch">\n</span><span class="st">"</span>)</span>
<span id="cb1-423"><a href="#cb1-423" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-424"><a href="#cb1-424" aria-hidden="true" tabindex="-1"></a>    end_time <span class="op">=</span> time.time()</span>
<span id="cb1-425"><a href="#cb1-425" aria-hidden="true" tabindex="-1"></a>    elapsed_time <span class="op">=</span> end_time <span class="op">-</span> start_time</span>
<span id="cb1-426"><a href="#cb1-426" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-427"><a href="#cb1-427" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> cycle:</span>
<span id="cb1-428"><a href="#cb1-428" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Final Result: Found a Hamiltonian cycle."</span>)</span>
<span id="cb1-429"><a href="#cb1-429" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb1-430"><a href="#cb1-430" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Final Result: Could not find a Hamiltonian cycle with the current edge set."</span>)</span>
<span id="cb1-431"><a href="#cb1-431" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-432"><a href="#cb1-432" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Total collected edges: </span><span class="sc">{</span><span class="bu">len</span>(non_blocking_edges)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-433"><a href="#cb1-433" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Total TSP edges (OR-Tools): </span><span class="sc">{</span><span class="bu">len</span>(tsp_edges_ortools)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-434"><a href="#cb1-434" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Execution Time: </span><span class="sc">{</span>elapsed_time<span class="sc">:.2f}</span><span class="ss"> seconds"</span>)</span>
<span id="cb1-435"><a href="#cb1-435" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-436"><a href="#cb1-436" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 6: Plot the results</span></span>
<span id="cb1-437"><a href="#cb1-437" aria-hidden="true" tabindex="-1"></a>    plot_results(points, non_blocking_edges, tsp_route_ortools, cycle, <span class="st">"Final"</span>)</span>
<span id="cb1-438"><a href="#cb1-438" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-439"><a href="#cb1-439" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-440"><a href="#cb1-440" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">"__main__"</span>:</span>
<span id="cb1-441"><a href="#cb1-441" aria-hidden="true" tabindex="-1"></a>    N <span class="op">=</span> <span class="dv">20</span></span>
<span id="cb1-442"><a href="#cb1-442" aria-hidden="true" tabindex="-1"></a>    seed <span class="op">=</span> <span class="dv">981222119</span></span>
<span id="cb1-443"><a href="#cb1-443" aria-hidden="true" tabindex="-1"></a>    main(N, seed)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="experimental-results" class="level1">
<h1>Experimental Results</h1>
<section id="implementation-details" class="level3">
<h3 class="anchored" data-anchor-id="implementation-details">Implementation Details</h3>
<p>The algorithm was tested with ( N = 20 ) points, using a fixed random seed for reproducibility. A 10x10 grid was employed for spatial partitioning, balancing computational efficiency and memory usage.</p>
</section>
<section id="performance-analysis" class="level3">
<h3 class="anchored" data-anchor-id="performance-analysis">Performance Analysis</h3>
<p>The algorithm successfully eliminated a significant number of blocking edges, reducing the total number of edges from 190 (fully connected graph) to 95 (non-blocking edges). The dynamic programming phase efficiently computed the shortest Hamiltonian cycle within the reduced edge set, matching the exact solution provided by OR-Tools.</p>
</section>
<section id="comparison-with-or-tools" class="level3">
<h3 class="anchored" data-anchor-id="comparison-with-or-tools">Comparison with OR-Tools</h3>
<p>The algorithm’s solution matched the exact TSP solution obtained via OR-Tools, indicating its effectiveness in accurately determining the optimal route. The elimination of blocking edges not only reduced the computational burden but also retained all edges critical to forming the optimal cycle.</p>
</section>
</section>
<section id="discussion" class="level1">
<h1>Discussion</h1>
<p>The exact visibility-based edge elimination algorithm presents a significant advancement in solving the TSP by reducing the solution space without compromising optimality. By eliminating edges that intersect and thereby block visibility between point pairs, the algorithm ensures that all necessary edges for the optimal solution are retained. The integration of spatial partitioning further enhances computational efficiency, making the algorithm more scalable for larger datasets.</p>
<section id="advantages" class="level2">
<h2 class="anchored" data-anchor-id="advantages">Advantages:</h2>
<ul>
<li><p><strong><code>Exactness</code></strong>: Guarantees that the optimal TSP cycle is found within the reduced edge set, as no essential edges are eliminated.</p></li>
<li><p><strong><code>Efficiency</code></strong>: Spatial partitioning significantly reduces the number of edge crossing checks from ( O(N^4) ) to approximately ( O(N^2) ), enhancing computational performance.</p></li>
<li><p><strong><code>Scalability</code></strong>: While demonstrated on ( N = 20 ), the approach is scalable to larger datasets with appropriate adjustments to grid size and further optimizations.</p></li>
</ul>
</section>
<section id="limitations" class="level2">
<h2 class="anchored" data-anchor-id="limitations">Limitations:</h2>
<ul>
<li><strong><code>Edge Cases</code></strong>: In highly dense or non-uniform point distributions, the number of edge crossings may still approach ( O(N^4) ), potentially impacting performance.</li>
<li><strong><code>Parameter Sensitivity</code></strong>: The choice of grid_size is crucial for balancing efficiency and memory usage. An inappropriate grid size may lead to suboptimal edge elimination or increased computational overhead.</li>
<li><strong><code>Dynamic Programming Constraints</code></strong>: The Held-Karp algorithm remains exponential in time complexity (( O(E* 2^N) )), limiting scalability to very large ( N ).</li>
</ul>
</section>
<section id="future-work" class="level2">
<h2 class="anchored" data-anchor-id="future-work">Future Work:</h2>
<ul>
<li>Adaptive Spatial Partitioning: Implementing adaptive grid sizing or more sophisticated spatial data structures like Quadtrees or R-trees could further optimize edge crossing checks.</li>
<li>Parallel Processing: Leveraging multi-threading or distributed computing frameworks to handle edge assignments and crossing checks concurrently.</li>
<li>Hybrid Algorithms: Combining visibility-based elimination with other exact or heuristic methods (e.g., branch and bound, cutting planes) to enhance solution quality and scalability.</li>
<li>Extensive Empirical Evaluation: Conducting comprehensive experiments across diverse datasets to benchmark performance, refine algorithm parameters, and explore applicability to larger and more complex instances of TSP.</li>
</ul>
</section>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<p>Solving the Traveling Salesman Problem with exactness and efficiency remains a pivotal goal in the field of optimization. Our visibility-based edge elimination algorithm, fortified with spatial partitioning, marks a significant step forward in this endeavor. By reducing computational complexity and ensuring the retention of essential edges, the algorithm provides a powerful tool for tackling TSP with unprecedented precision and speed. The successful alignment of our results with established optimization tools like OR-Tools underscores the potential of this approach, paving the way for future innovations in combinatorial optimization.</p>
<p>I am excited to share these findings with the professional community and welcome discussions, collaborations, and insights that can further advance the capabilities and applications of this algorithm.</p>
<p>Feel free to reach out if you’re interested in discussing this research further or exploring potential collaborations!</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>